# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
  batch: true
  branches:
    include:
    - main
    - test

pr:
  branches:
    include:
    - master
    - test

parameters:
- name: environment
  displayName: 'Environment: test or prod'
  type: string
  default: none
  values:
    - none
    - test
    - prod

pool:
  vmImage: 'windows-latest'

steps:
- checkout: self
  persistCredentials: true

- script: echo Hello, world!
  displayName: 'Run a one-line script'

- script: |
    echo Add other tasks to build, test, and deploy your project.
    echo See https://aka.ms/yaml
  displayName: 'Run a multi-line script'

- powershell: |
    Write-Host "Tagging Build: $env:BuildNumber"
    $currentCommit = git rev-parse HEAD # is this correct?

    git tag $env:BuildNumber
    git push origin $env:BuildNumber

    $username = 'JAndersen'
    $password = 'VG6NdUpB'

    $bytes = [System.Text.Encoding]::UTF8.GetBytes("$username`:$password")
    $encodedCredentials = [System.Convert]::ToBase64String($bytes)

    function Get-JiraIssue {    
      # We need authentication token
      param([string] $issueId)
      return Invoke-RestMethod -Uri "https://jira.3shape.com/rest/api/latest/issue/$issueId" -Headers @{"Authorization" = "Basic $encodedCredentials" } -ContentType application/json 
    }

    $currentDeployedTag = (Invoke-webrequest -URI "https://www.3shape.com/currentbuildtag.txt").Content
    $currentDeployedCommit = git show-ref -s $currentDeployedTag

    Write-Host "Currently deployed tag and commit:" $currentDeployedTag $currentDeployedCommit

    $commits = git log --pretty=oneline "$currentDeployedCommit...$currentCommit" --no-decorate --no-merges --pretty=format:"%ai`t%H`t%an`t%ae`t%s" | ConvertFrom-Csv -Delimiter "`t" -Header ("Commit Date", "Commit Id", "Commit Author", "Commit Email", "Commit Message")

    Write-Host "Got git log of commits"

    $commits | ForEach-Object {
        if ($_."Commit Message" -match "(^[a-zA-Z]{2,8}\-[0-9]+)") {
            Write-Host "Match on $($_."Commit Message")"
            $jiraIssue = Get-JiraIssue($Matches[0])
            Write-Host "Jira issue key " $jiraIssue.key
            $_ | Add-Member -NotePropertyName "Jira Key" -NotePropertyValue $jiraIssue.key
            $_ | Add-Member -NotePropertyName "Jira URL" -NotePropertyValue "$jira_url/browse/$($jiraIssue.key)"
            $_ | Add-Member -NotePropertyName "Jira Summary" -NotePropertyValue $jiraIssue.fields.summary
            $_ | Add-Member -NotePropertyName "Jira Project Key" -NotePropertyValue $jiraIssue.fields.project.key
            $_ | Add-Member -NotePropertyName "Jira Project Name" -NotePropertyValue $jiraIssue.fields.project.name
        }
        else {
            Write-Host "No match on $($_."Commit Message")"
            $_ | Add-Member -NotePropertyName "Jira Key" -NotePropertyValue $_."Commit Id"
            $_ | Add-Member -NotePropertyName "Jira URL" -NotePropertyValue ""
            $_ | Add-Member -NotePropertyName "Jira Summary" -NotePropertyValue $_."Commit Message"
            $_ | Add-Member -NotePropertyName "Jira Project Key" -NotePropertyValue "NoProjectKey"
            $_ | Add-Member -NotePropertyName "Jira Project Name" -NotePropertyValue "Not related to Jira"
        }  
    }

    Write-Host "Checked for commit messages"

    $projects = $commits | Select-Object "Jira Project Name", "Jira Project Key" | sort-object -Property "Jira Project Name" -Unique 
    $projects = @($projects)
    $projects | ForEach-Object {
        $projectName = $_."Jira Project Name"
        $projectKey = $_."Jira Project Key"
        $_ | Add-Member -NotePropertyName "Number of commits" -NotePropertyValue (@($commits | Where-Object { $_."Jira Project Name" -eq $projectName } )).Count
        $_ | Add-Member -NotePropertyName "Number of Jira Issues Affected" -NotePropertyValue @($commits | Where-Object { $_."Jira Project Key" -eq $projectKey } | Group-Object -Property "Jira Key" | Select-Object Name, Count  ).Count
    }

    $releaseNotes += "<p>Release notes from comparing release <code>$tag1</code> with <code>$tag2</code></p>";
    Write-Host "Release notes from comparing release $tag1 with $tag2"
    $releaseNotes += "<h1>Projects included in this release</h1>";
    Write-Host "Projects included in this release"
    $releaseNotes += $projectTable | ConvertTo-Html -Fragment
    $projectTable | Format-Table

    $projects | ForEach-Object {
        $releaseNotes += "<h2>Project: $($_."Jira Project Name")</h2>"
        Write-Host "Project: $($_."Jira Project Name")"
        $projectKey = $_."Jira Project Key"
        $tickets = $commits | Where-Object { $_."Jira Project Key" -eq $projectKey } | Select-Object "Jira Key", "Jira URL", "Jira Summary" | sort-object -Property "Jira Key" -Unique 

        $ticketsTable = $tickets | Select-Object -Property @{N = "Jira #"; E = { "<a href=""$($_."Jira URL")"">$($_."Jira Key")</a>" } }, @{N = "Jira Summary" ; E = { [System.Web.HttpUtility]::HtmlEncode($_."Jira Summary")} } 
        $ticketsTable | Format-Table
        $releaseNotes += $ticketsTable | ConvertTo-Html -Fragment;
    }

    $decoded = [System.Web.HttpUtility]::HtmlDecode($releaseNotes);
    echo "##vso[task.setvariable variable=releasenotesfromjira]$decoded"



  env:
    BuildNumber: $(Build.BuildNumber)
  displayName: "Create release notes from last deploy up to this deploy"
- powershell: |
    New-Item .\currentbuildtag.txt
    Set-Content .\currentbuildtag.txt '$Build.BuildNumber'
  displayName: "Update file containing current build number"
- task: GitHubRelease@0
  displayName: 'Create GitHub Release'      
  inputs:
    gitHubConnection: github.com_jimmilyhne
    repositoryName: '$(Build.Repository.Name)' #jimmilyhne/TestRepoRD
    action: 'create'
    tagSource: 'auto'
    tag: $(Build.BuildNumber)
    #title: # Optional
    releaseNotesSource: 'input' # Optional. Options: file, input
    #releaseNotesFile: # Optional
    releaseNotes: "$(releasenotesfromjira)"
    # assets: |
    #   $(Build.ArtifactStagingDirectory)/*.exe
    #   $(Build.ArtifactStagingDirectory)/README.txt
